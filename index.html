<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>F# Will Make You a Better .Net Developer - adamkrieger.ca</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">


    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <link rel="stylesheet" href="css/font-awesome.css">
    <!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->

    <link rel="stylesheet" href="css/ak-speaking.css">
</head>

<body>

    <img id="aklogo" src="img/aklogo.png" />
    <img id="onlinelogo" src="img/Online_logo.png" />

    <div class="reveal">

        <!-- Any section element inside of this container is displayed as a slide -->
        <div class="slides">
            <section>
                <div id="titleslide">
                    <div id="sessionbanner">
                        <div id="logo">
                            <img src="img/PrDC_logo.png" />
                        </div>
                        <div id="sessiontitle">
                            <span>F# WILL MAKE YOU A BETTER .NET DEVELOPER</span>
                            <br />
                            <br />
                            <span>ADAM KRIEGER</span>
                        </div>
                    </div>
                    <div id="sponsors">
                        <span>SPONSORS</span>
                        <img src="img/sponsors.png" />
                    </div>
                </div>
            </section>
            <section>
                <h1>F#</h1>
                <h2>Will Make <i><u>You</u></i> <br />a Better .Net Developer</h2>
                <i class="icon ion-home"></i>
                <div style="width: 300px; padding-left: 100px; margin: auto">
                    <p style="text-align: left">
                        <small>by Adam Krieger</small>
                        <br />
                        <small><i class="fa fa-twitter"></i> @adamkrieger</small>
                        <br />
                        <small><i class="fa fa-chrome"></i> www.adamkrieger.ca</small>
                        <br />
                        <small><i class="fa fa-github"></i> adamkrieger</small>
                        <br />
                    </p>
                </div>
                <a href="https://github.com/adamkrieger/FSBetter">https://github.com/adamkrieger/FSBetter</a>
            </section>

            <section>
                <section>
                    <h4>The Dilemma</h4>
                    <table>
                        <tr>
                            <td>
                                <h2 style="text-align: center">Depth</h2>
                                <img src="img/Csharp_nutshell.png" height="400px" />
                            </td>
                            <td>
                                <p>vs</p>
                            </td>
                            <td>
                                <h2 style="text-align: center">Breadth</h2>
                                <img src="img/fsharp512.png" height="340px" />
                                <h5 style="text-align: center">fsharp.org</h5>
                            </td>
                        </tr>
                    </table>
                </section>
            </section>

            <section>
                <section>
                    <h2>Why is it 'Better'?</h2>
                    <p>Types -> Enhanced Safety</p>
                    <p>Funcs -> Roll-Forward Flow</p>
                    <p>.Net  -> Pragmatic Leverage</p>
                </section>
            </section>
            
            <section>
                <section data-transition="fade">
                    <img src="img/feedbackloop.png"/>
                </section>
            </section>
            
            <section>
                <section>
                    <h3>Foundation</h3>
                    <table>
                        <tr><td>No nulls!</td><td><i>Absence of Absence</i></td></tr>
                        <tr><td><pre><code class="fs">let x = 1</code></pre></td><td><i>Binding instead of Declaraction & Assignment</i></td></tr>
                        <tr><td>Immutability</td><td><i>Your Values are Safe</i></td></tr>
                        <tr><td><pre><code class="fs">val |> fun</code></pre></td><td><i>Sequential Cohesion</i></td></tr>
                    </table>
                </section>
                <section>
                    <h5>Foundation</h5>
<pre><code class="fs">
type Item = { Price: decimal }

let withTax price = price * 1.14M; // price:decimal -> decimal

let shirt = { Price = 10.00M }

do shirt.Price
|> withTax
|> printfn "%.2f"

</code></pre>
                </section>
                <section>
                    <h5>Foundation: Error-prone C#</h5>
<pre><code class="cs" style="max-height: 500px;">
public class Item{
    public decimal Price;
    public decimal WithTax()
    {
        Price *= 1.14M;
        return Price;
    }
}

Item shirt;
// Oops #1: shirt is null

shirt = new Item(); 
// Oops #2: shirt.Price is 0
shirt.Price = 10.00M;

var priceWithTax = shirt.WithTax();
//Oops #3: shirt.Price has been changed to 11.40

</code></pre>
                </section>
                <section>
                    <h5>Foundation: Safe-ish C#</h5>
<pre><code class="cs" style="max-height: 500px">public class ImmutableItem
{
    private ImmutableItem(){}
    private ImmutableItem(decimal price){ this.Price = price; }
    
    public readonly decimal Price;
    
    public static ImmutableItem Create(decimal price){
        return new ImmutableItem(price);
    }
    
    public decimal WithTax(){
        //Price *= 1.14M; <-- A readonly field cannot be assigned to
        return Price * 1.14M;
    }
}

var shirt = ImmutableItem.Create(10.00M);
var priceWithTax = shirt.WithTax();
Console.WriteLine(priceWithTax);
</code></pre>
                </section>
                <section>
                    <h5>Foundation: Conclusion</h5>
                    <table style="width: 80%">
                        <tr><td>Constructors</td><td><i>Lock 'em down</i></td></tr>
                        <tr><td><pre><code class="fs">readonly</code></pre></td><td><i>Explicitly declare intent</i></td></tr>
                    </table>
<pre><code class="fs">type Item = { Price: decimal }

let withTax price = price * 1.14M; // price:decimal -> decimal

let shirt = { Price = 10.00M }

do shirt.Price
|> withTax
|> printfn "%.2f"
</code></pre>
                </section>
            </section>
            
            <section>
                <section>
                    <h3>Form</h3>
                    <table style="width: 90%">
                        <tr><td>Variety</td><td><i>The spice of Life!</i></td></tr>
                        <tr><td>Decomposition</td><td><i>Good for the environment!</i></td></tr>
                        <tr><td>Inference</td><td><i>The compiler comes to you</i></td></tr>
                        <tr><td>Currying</td><td><i>Enough spice, already!</i></td></tr>
                    </table>
                </section>
                
                <section>
                    <h5>Form: Composition/Decomposition</h5>
<pre><code class="fs">
let point = 4, 5
let x, y = point

type person = { FirstName: string; LastName: string }
let amySmith = { FirstName = "Amy"; LastName = "Smith" }
let { LastName = smith } = amySmith

</code></pre>
                    <i>No need for GetHashCode() or Equals()!</i>
                </section>
                
                <section>
                    <h3>Variety</h3>
                    <table style="width: 80%">
                        <tr><td>Tuples</td><td><i>Light as a feather</i></td></tr>
                        <tr><td>Records</td><td><i>Immutable Databags</i></td></tr>
                        <tr><td>Unions</td><td><i>This, That, or the Other</i></td></tr>
                        <tr><td>Lists</td><td><i>Collections, redefined</i></td></tr>
                        <tr><td>Functions</td><td><i>Automatically curried</i></td></tr>
                    </table>
                </section>
                
                <section>
                    <h5>Form: Leveraging Safety</h5>
<pre><code class="fs" style="max-height: 500px">type Username     = string
type Password     = Password of string
type Server       = URL of string | IP of byte[]
type HttpResponse = Response of int * string
</code></pre>
                </section>
                
                <section>
                    <h5>Form: Leveraging Safety</h5>
<pre><code class="fs" style="max-height: 500px">type Username     = string
type Password     = Password of string
type Server       = URL of string | IP of byte[]
type HttpResponse = Response of int * string
    
let sendSecureMessageToServer (name:Username) (pword:Password) 
                              (dest:Server) message =
    Response (200, "Delivered Successfully")
     
let password = Password "12345"
let url = URL "https://localhost:9999/api/messages"

let sendMessage = sendSecureMessageToServer "johnny" password url 
do sendMessage "Oh hi, Mark."      |> ignore
do sendMessage "I have a problem." |> ignore

let sendNumber = sendSecureMessageToServer "mark" password url
do sendNumber 9001                 |> ignore
</code></pre>
                </section>
                
                <section>
                    <h5>Form: Conclusion</h5>
                    <table>
                        <tr><td>Types</td><td><i>Declare intent</i></td></tr>
                        <tr><td>Composition</td><td><i>Over construction</i></td></tr>
                        <tr><td>Safety</td><td><i>Lint the danger</i></td></tr>
                        <tr><td>Currying</td><td><i>Without heavy DSLs</i></td></tr>
                    </table>
                </section>
            </section>
            
            <section>
                <section>
                    <h3>Functions!</h3>
                    <ul>
                        <li>fun: Lame joke alert.</li>
                        <li>Pattern Matching: Declarative control flow</li>
                        <li>option: Practical Monads</li>
                        <li>'>>': Effortless composition</li>
                    </ul>
                </section>
                
                <section>
                    <h5>Form: Safety in 7 Lines</h5>
<pre><code class="fs" style="max-height: 500px">let getName =
    function 
    | Some cheese -> printfn "%s" cheese.Name
    | None        -> printfn "%s" "Completely out."
    
let pickCheese id =
    List.tryFind (fun item -> item.Id = id)
    >> getName
</code></pre>
                </section>
                
                <section>
                    <h5>Form: Unsafe C# (11 Lines)</h5>
<pre><code class="cs" style="max-height: 500px">public Cheese GetCheese(Cheese[] cheeses, string id){
    Cheese foundCheese = null;
    
    foreach (var cheese in cheeses){
        if(cheese.id == id){
            foundCheese = cheese;
        }
    }
    
    return foundCheese;
}

var cheese = GetCheese(cheeses, "rwin");
</code></pre>
                </section>
                
                <section>
                    <h5>Form: Safe C# (27 Lines)</h5>
<pre><code class="cs" style="max-height: 500px">public bool GetCheese(Cheese[] cheeses, string id,
    out Cheese notAtAllObviousActualValue){
        
    foreach (var cheese in cheeses){
        if(cheese.id == id){
            notAtAllObviousActualValue = cheese;
            return true;
        }
    }
    notAtAllObviousActualValue = null;
    return false;
}

string outputMessage = string.Empty;
Cheese cheese = null;

if(GetCheese(cheeses, "none", out cheese)){
    outputMessage = cheese.name;    
}
else{ outputMessage = "Could not find cheese."; }
</code></pre>
                </section>
                
                <section>
                    <h5>Form: A C# Maybe</h5>
<pre><code class="cs" style="max-height: 500px">using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;

public class Maybe&lt;T>
{
    public readonly T Value;
    public readonly bool Is; 
    
    private Maybe(){}
    private Maybe(bool isSome, T value){
        Is = isSome;
        Value = value;
    }
    
    public static Maybe&lt;T> Some(T value){
        return new Maybe&lt;T>(true, value);
    }
    
    public static Maybe&lt;T> None(){
        return new Maybe&lt;T>();
    }
    
    public Maybe&lt;T> IfIs(Action&lt;T> action){
        if(Is){
            action(Value);
        }
        return this;
    }
    
    public Maybe&lt;T> IfIsNot(Action action){
        if(!Is){
            action();
        }
        return this;
    }
}

public static class EnumExt
{
    public static Maybe&lt;T> TrySingle&lt;T>(
        this IEnumerable&lt;T> collection, Func&lt;T, bool> pred)
    {
        try{
            return Maybe&lt;T>.Some(collection.Single(pred));
        }
        catch(InvalidOperationException){
            return Maybe&lt;T>.None();
        }
    }
}
</code></pre>
                </section>
                
                <section>
                    <h5>Form: Safe C# (4+50 Lines)</h5>
<pre><code class="cs" style="max-height: 500px">cheeses
    .TrySingle(cheese => cheese.id == "ched")
    .IfIs(a => Console.WriteLine(a.name))
    .IfIsNot(() => Console.WriteLine("Not found."));
</code></pre>
                </section>

                
                <section>
                    <h3>Functions: Conclusion</h3>
                    <ul>
                        <li>Stop using 'out' parameters</li>
                        <li>Build your own Maybe</li>
                        <li>Enhance LINQ/Streams</li>
                    </ul>
<pre><code class="fs" style="max-height: 500px">let getName =
    function 
    | Some cheese -> printfn "%s" cheese.Name
    | None        -> printfn "%s" "Completely out."
    
let pickCheese id =
    List.tryFind (fun item -> item.Id = id)
    >> getName
</code></pre>
                </section>
            </section>
            
            <section>
                <section data-transition="fade">
                    <img src="img/feedbackloop.png"/>
                </section>
                
                <section data-transition="fade">
                    <img src="img/feedbackloop_accel.png"/>
                </section>
            </section>

            
            <section>
                <section>
                    <h3>Railway-oriented Programming!</h3>
                    <ul>
                        <li>bind: Cohesive Complexity</li>
                        <li>choice: What?! Another Monad?</li>
                        <li>option: Practical Monads</li>
                        <li>'>>': Effortless composition</li>
                    </ul>
                </section>
                
                <section>
                    <h5>Plug-in Validation</h5>
<pre><code class="fs" style="max-height: 500px">input
|> idNotZero
|> bind actuallyGoingSomewhere
|> bind addPlanet
|> function
    | Success booking -> printfn "Have fun in %s!" booking.Destination
    | Failure error -> printfn "%s" error
</code></pre>
                </section>
                
                <section>
                    <h5>Start with one</h5>
<pre><code class="fs" style="max-height: 500px">type Booking = { Id: int;
                 Destination: string }
    
let idNotZero booking = 
    match booking.Id with
    | 0 -> None
    | id -> Some booking
    
let input = {
        Id = 2;
        Destination = "France"
    }

input
|> idNotZero
|> function
    | Some booking -> printfn "Have fun in %s!" booking.Destination
    | None -> printfn "%s" "Oops!"
</code></pre>
                </section>
                
                <section>
                    <h5>Add another</h5>
<pre><code class="fs" style="max-height: 500px">let idNotZero booking = 
    match booking.Id with
    | 0 -> None
    | id -> Some booking
    
let actuallyGoingSomewhere =
    function
    | None -> None
    | Some booking ->
        booking.Source = booking.Destination
        |> function
            | true -> None
            | false -> Some booking  
</code></pre>
                    <i>But design for N</i>
                </section>
                
                <section>
                    <h5>Option.bind</h5>
<pre><code class="fs" style="max-height: 500px">let idNotZero booking = 
    match booking.Id with
    | 0 -> None
    | id -> Some booking
    
let actuallyGoingSomewhere booking =
    booking.Source = booking.Destination
    |> function
       | true -> None
       | false -> Some booking
       
input
|> idNotZero
|> Option.bind actuallyGoingSomewhere
|> Option.bind planetExists
|> function
    | Some booking -> printfn "Have fun in %s!" booking.Destination
    | None -> printfn "%s" "Oops!"
</code></pre>
                    <i>But which one failed?</i>
                </section>
                
                <section>
                    <h5>Custom 'switcher'</h5>
<pre><code class="fs" style="max-height: 500px">type Result<'TSuccess, 'TFailure> =
    | Success of 'TSuccess
    | Failure of 'TFailure 

let bind f = fun eitherInput ->
                match eitherInput with
                | Success x -> f x
                | Failure x -> Failure x
        
let idNotZero booking = match booking.Id with
                        | 0 -> Failure "Oops, the id is zero."
                        | id -> Success booking
    
input
|> idNotZero
|> bind actuallyGoingSomewhere
|> bind addPlanet
|> function
    | Success booking -> printfn "Have fun in %s!" booking.Destination
    | Failure error -> printfn "%s" error
</code></pre>
                </section>
                
                <section>
                    <h3>Railways: Conclusion</h3>
                    <ul>
                        <li>Stop using 'out' parameters</li>
                        <li>Build your own Maybe</li>
                        <li>Enhance LINQ/Streams</li>
                        <li>Generic Composition instead of 'DSL'</li>
                    </ul>
                </section>
            </section>
            
            <section>
                <h2>Thank you.</h2>
            </section>

            <section>
                <h2>Disclaimer</h2>
                <p>The addition of more tools and code can often make up for C#'s lack of paradigm...</p>
                <p><i>but then you'd have to maintain those tools.</i></p>
                
                
                                <section>
                    <h5>Form: An Immutable Quicksort</h5>
<pre><code class="fs" style="max-height: 500px">let rec sortIter lt eq gt list pivot =
     match list with
     | [] -> lt, eq, gt
     | head::tail when head < pivot -> 
                                sortIter (head::lt) eq gt tail pivot
                                
     | head::tail when head > pivot -> 
                                sortIter lt eq (head::gt) tail pivot
                                
     | head::tail -> 
                                sortIter lt (head::eq) gt tail pivot
            
let rec qsort list = 
    match list with
    | []          -> []
    | pivot::tail -> let lt, eq, gt = sortIter [] [] [] tail pivot
                     List.collect id [ qsort lt; [pivot]; eq; qsort gt ]
</code></pre>
                </section>
            </section>


            <!-- MUTABILITY / IMMUTABILITY -->
            <section>
                <section>
                    <h2>The Mutability Problem</h2>
                </section>
                <section data-transition="fade">
                    <img src="img/mutability.png" />
                </section>
                <section data-transition="fade">
                    <img src="img/mutability2.png" />
                </section>
                <section data-transition="fade">
                    <img src="img/mutability3.png" />
                </section>
                <section data-transition="fade">
                    <img src="img/mutability4.png" />
                </section>
            </section>

            <section>
                <section>
                    <h2>Mutability in C#</h2>
                    <pre><code class="cs" data-trim contenteditable>
var bucket = "Really Important Value";
bucket = "Another Important Value";

Console.WriteLine(bucket);
</code></pre>
                    <pre><code data-trim contenteditable>
$ csi 1.1_mut.csx
Another Important Value
</code></pre>
                </section>
                <section>
                    <h2>Immutability in F#</h2>
                    <pre><code class="fs" data-trim contenteditable>
let bucket = "Really Important Value"
bucket = "Another Important Value"
// let bucket = "Something else" <- Error: Duplicate definition

let bucket2 = bucket = "Another Important Value"

printfn "%s" bucket
printfn "%A" bucket2
</code></pre>
                    <pre><code data-trim contenteditable>
$ fsi 1.2_mut.fsx
Really Important Value
false
</code></pre>
                </section>
                <section>
                    <h2>Somewhat Immutable C#</h2>
                    <pre><code class="cs" data-trim contenteditable>
public class ImmutString
{
    public ImmutString(string value){
        this.Value = value;
    }
    
    public readonly string Value;
}

var bucket = new ImmutString("Really Important Value");
// Error: Readonly field cannot be assigned to.
// bucket.Value = "Another Important Value";

Console.WriteLine(bucket.Value);
</code></pre>
                    <pre><code data-trim contenteditable>
$ csi 1.3_mut_next.csx
Really Important Value
</code></pre>
                </section>

                <aside class="notes">
                    Our initial C# example shows us how easy it is for values to change under our nose. F# makes every assignment immutable by
                    default. (Overridable with the mut keyword). 'readonly' gets us closer, but C# will still allow the parent
                    class assignment to be overwritten. In this case, F# shows us developer what we have to watch our for:
                    values changing under our noses.
                </aside>
            </section>

            <!-- Safe Programming -->
            <section>
                <section data-transition="fade">
                    <h2>Defensive Programming</h2>
                    <img src="img/fryisntsure.jpg" />
                </section>
                <section data-transition="fade">
                    <h2>Excessive Scrutiny</h2>
                    <img src="img/fryisntsure.jpg" />
                </section>
                <section>
                    <h2>Unsafe Methods (15 lines)</h2>
                    <pre><code class="cs" data-trim contenteditable>
public Cheese GetCheese(Cheese[] cheeses, string id){
    Cheese foundCheese = null;
    
    foreach (var cheese in cheeses){
        if(cheese.id == id){
            foundCheese = cheese;
        }
    }
    
    return foundCheese;
}

var cheese = GetCheese(cheeses, "rwin");

Console.WriteLine(cheese.name);
</code></pre>
                    <pre><code data-trim contenteditable>
$ csi 2.1_input.csx
Red Windsor
</code></pre>
                </section>
                <section>
                    <h2>Safe Methods (24 lines)</h2>
                    <pre><code class="cs" data-trim contenteditable>
#load "0.1_Cheese.csx"
//      Defensive
public bool GetCheese(Cheese[] cheeses, string id,
    out Cheese notAtAllObviousActualValue) { // Defensive
        
    foreach (var cheese in cheeses) {
        if(cheese.id == id) {
            notAtAllObviousActualValue = cheese;
            return true; //Defensive
        }
    }
    
    notAtAllObviousActualValue = null;
    return false; //Defensive
}

string outputMessage = string.Empty;
Cheese cheese = null; //Defensive
// Defensive
if(GetCheese(cheeses, "none", out cheese)) {
    outputMessage = cheese.name;    
}
else {
    outputMessage = "Could not find cheese.";
}

Console.WriteLine(outputMessage);
</code></pre>
                    <pre><code data-trim contenteditable>
$ csi 2.2_input_safe.csx
Could not find cheese.
</code></pre>
                </section>
            </section>

            <section>
                <section>
                    <h3>Where's Waldo?</h3>
                    <ul>
                        <li>Anonymous Function</li>
                        <li>List Processor (LISP)</li>
                        <li>Option(Maybe) Monad</li>
                        <li>Pattern Matcher</li>
                        <li>Function Composition</li>
                    </ul>
                </section>
                <section>
                    <h2>Function and Fashion</h2>
                    <pre><code class="fs" data-trim contenteditable>
let pickCheese id =
    Array.tryFind (fun item -> item.Id = id)
    >> function 
       | Some cheese -> printfn "%s" cheese.Name
       | None        -> printfn "%s" "Completely out."
 
// id:string -> (Cheese[] -> unit)
pickCheese "none" cheeses
</code></pre>
                    <pre><code data-trim contenteditable>
$ fsi 2.3_input.fsx
Completely out.
</code></pre>
                </section>
                <section>
                    <pre><code class="fs" data-trim contenteditable>
let pickCheese id =
    // LISP        Anon Func
    Array.tryFind (fun item -> item.Id = id)
    // Composition of functions
    >> function 
        // Pattern Matcher
       | Some cheese -> printfn "%s" cheese.Name
            // Option of Some or None
       | None        -> printfn "%s" "Completely out."
 
// id:string -> (Cheese[] -> unit)
pickCheese "none" cheeses
</code></pre>
                </section>
            </section>

            <section>
                <section>
                    <h2>Monads</h2>
                    <p><i>A brief interlude</i></p>
                </section>
                <section>
                    <h2>What is Null? (C#)</h2>
                    <ul>
                        <li class="fragment">Possible absence of value</li>
                        <li class="fragment">Possible indication of empty</li>
                        <li class="fragment">Stateful, as in DateCancelled</li>
                        <li class="fragment">Value of any reference Type</li>
                    </ul>
                </section>
                <section>
                    <h2>What is None? (F#)</h2>
                    <ul>
                        <li>Absence of Value of option types</li>
                    </ul>
                </section>
                <section>
                    <h2>Why use None over Null?</h2>
                    <pre><code class="cs" data-trim contenteditable>
// C#: Null is of the same type as the expected value, and...
//     It compiles and ships *to your customer*!
string[] stringArray;

var length = stringArray.Length;
</code></pre>
                    <p>vs</p>
                    <pre><code class="fs" data-trim contenteditable>
// F#
let stringArray = Some [| "elem" |] //Can't declare without assignment

// Will not compile, as stringArray is 'string[] option'
let item = stringArray.Length 
// Absence as a first class citizen
let firstElement = 
    stringArray |> function
             | Some arr when arr.Length > 0 -> Some arr.[0] 
             | _ -> None 
</code></pre>
                </section>
            </section>

            <section>
                <section>
                    <h2>A C# Maybe</h2>
                    <pre><code class="cs" style="max-height: 500px" data-trim contenteditable>
// csc /target:library 0.2_Maybe.csx
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;

public class Maybe&lt;T>
{
    public readonly T Value;
    public readonly bool Is; 
    
    private Maybe(){}
    private Maybe(bool isSome, T value){
        Is = isSome;
        Value = value;
    }
    
    public static Maybe&lt;T> Some(T value){
        return new Maybe&lt;T>(true, value);
    }
    
    public static Maybe&lt;T> None(){
        return new Maybe&lt;T>();
    }
    
    public Maybe&lt;T> IfIs(Action&lt;T> action){
        if(Is){
            action(Value);
        }
        return this;
    }
    
    public Maybe&lt;T> IfIsNot(Action action){
        if(!Is){
            action();
        }
        return this;
    }
}

public static class EnumExt
{
    public static Maybe&lt;T> TrySingle&lt;T>(
        this IEnumerable&lt;T> collection, Func&lt;T, bool> pred)
    {
        try{
            return Maybe&lt;T>.Some(collection.Single(pred));
        }
        catch(InvalidOperationException){
            return Maybe&lt;T>.None();
        }
    }
}
</code></pre>
                </section>
                <section>
                    <h2>Safe, Functional, C#</h2>
                    <pre><code class="cs" style="max-height: 500px" data-trim contenteditable>
#r "0.2_Maybe.dll"
#load "0.1_Cheese.csx"

cheeses
    .TrySingle(cheese => cheese.id == "ched") //Returns Maybe&lt;string>
    .IfIs(a => Console.WriteLine(a.name)) //Also returns Maybe&lt;string>
    .IfIsNot(() => Console.WriteLine("Not found."));
</code></pre>
                </section>
            </section>


            <section>
                <section>
                    <h2>Immutable Performance</h2>
                </section>
                <section data-transition="fade">
                    <img src="img/immutability_bloat.png" />
                </section>
                <section data-transition="fade">
                    <img src="img/immutability_lean.png" />
                </section>
            </section>

            <section>
                <section>
                    <h2>Pattern Matching</h2>
                    <p><i>Handling data with a safety net.</i></p>
                </section>
                <section>
                    <h2>The Hanging default:</h2>
                    <pre><code class="cs" style="max-height: 500px" data-trim contenteditable>
public enum StarRating
{ Five, Four, Three, Two, One }

var rating = StarRating.Three;
var commission = 0.0;
var perNight = 300.0;

Console.WriteLine(string.Format(
    "StarTest: {0}", StarRating.Five > rating));

switch(rating){
    case StarRating.Five:
        commission = perNight * .13;
        break;
    case StarRating.Four:
        commission = perNight * .11;
        break;
    case StarRating.Three:
        commission = perNight * .09;
        break;
    case StarRating.Two:
        commission = perNight * .07;
        break;
    default:
        commission = perNight * .05;
        break;
}

Console.WriteLine(string.Format("Commission: {0}", commission));
</code></pre>
                </section>
                <section>
                    <h2>Discriminated Unions</h2>
                    <pre><code class="fs" data-trim contenteditable>
type StarRating =
        | One | Two | Three | Four | Five 

let commission perNight starRating = 
    match starRating with
    | StarRating.Five -> perNight * 0.13 
    | StarRating.Four -> perNight * 0.11
    | StarRating.Three -> perNight * 0.09
    
printfn "Per Night Commission: %A" (commission 300.0 StarRating.Three)
</code></pre>
                    <pre><code data-trim contenteditable>
$ fsi --warnaserror 3.2_discrim_unions.fsx
3.2_discrim_unions.fsx(5,11): error FS0025: Incomplete pattern matches on this expression. 
For example, the value 'One' may indicate a case not covered by the pattern(s).
</code></pre>
                </section>
                <section>
                    <h2>Free Equality</h2>
                    <pre><code class="fs" style="max-height: 500px" data-trim contenteditable>
type StarRating =
        | One | Two | Three | Four | Five 
        
type GolfScore =
        | Eight | Seven | Six | Five
        | Four | Three | Two | One
        
let starTest = StarRating.Five > StarRating.Four // True
let golfTest = GolfScore.One > GolfScore.Three // Also True

let commission perNight starRating = 
    match starRating with
    | StarRating.Five -> perNight * 0.13 
    | StarRating.Four -> perNight * 0.11
    | StarRating.Three -> perNight * 0.09
    | StarRating.Two -> perNight * 0.07
    | StarRating.One -> perNight * 0.05
    
printfn "Per Night Commission: %A" (commission 300.0 StarRating.Three)
</code></pre>
                </section>
            </section>

            <section>
                <section>
                    <h2>Getting the value from F#unctional</h2>
                    <p><i>When in a .Net shop</i></p>
                </section>
                <section>
                    <h3>Boostrapping the example</h3>
                    <pre><code class="cs" style="max-height: 500px" data-trim contenteditable>
using System;

public enum PaymentType
{
    Cash, Visa, Mastercard, Chickens
}

public class Bill
{
    public DateTime DatePaid {get;set;}
    public decimal Amount {get;set;}
    public PaymentType TypeOfPayment {get;set;}    
}

public interface IBillProcessor
{
    void PayBill(int id, Bill bill);
}
</code></pre>
                </section>
                <section>
                    <h4>Existing Flow</h4>
                    <pre><code class="cs" style="max-height: 500px" data-trim contenteditable>
#r "6.1_BillPay.dll"

public class BillProcessor : IBillProcessor
{
    public void PayBill(int id, Bill bill){
        Console.WriteLine(string.Format(
         "Paying bill {0}, paid with {1}, in the amount of ${2} on {3}.", 
         id, bill.TypeOfPayment, bill.Amount, bill.DatePaid));
    }
}

IBillProcessor billProcessor = new BillProcessor();

billProcessor.PayBill(
    24,
    new Bill(){ DatePaid = DateTime.Now,
                Amount = 13.28M,
                TypeOfPayment = PaymentType.Cash }
);
</code></pre>
                </section>
                <section>
                    <h4>Implementing a C# Interface in F#</h4>
                    <pre><code class="fs" style="max-height: 500px" data-trim contenteditable>
module ReplacementBillPayProcessors
#r "6.1_BillPay.dll"

type BetterBillProcessor() =
    let calculateTax paymentMethod paymentAmount = 
        match paymentMethod with
        | PaymentType.Chickens -> paymentAmount * 1.17M
        | PaymentType.Mastercard
        | PaymentType.Visa
        | PaymentType.Cash -> paymentAmount * 1.05M

    interface IBillProcessor with
        member this.PayBill(id, bill) =
            let taxedAmount = calculateTax bill.TypeOfPayment bill.Amount
        
            printfn 
                "Paying bill in %d in F#, paid with %A, in the amount of $%.2f on %A." 
                id bill.TypeOfPayment taxedAmount bill.DatePaid
</code></pre>
                </section>
                <section>
                    <h4>Using the F# Implementation from C#</h4>
                    <pre><code class="cs" style="max-height: 500px" data-trim contenteditable>
#r "6.3_BillPayFs.dll"

IBillProcessor billProcessor = 
    new ReplacementBillPayProcessors.BetterBillProcessor();

billProcessor.PayBill(
    24,
    new Bill(){
        DatePaid = DateTime.Now,
        Amount = 13.28M,
        TypeOfPayment = PaymentType.Cash
    }
);
</code></pre>
                </section>
            </section>
            
            <section>
                <section>
                    <h3>Canned Challenge</h3>
                    <ul>
                        <li>Take an int n</li>
                        <li>Take x more ints, printing each n-times</li>
                    </ul>
                </section>
                <section>
                    <img src="img/challenge1_sample.PNG" />
                </section>
                <section>
                    <h5>1 of 6</h5>
                    <pre><code class="fs" style="max-height: 500px" data-trim contenteditable>
module ReplacementBillPayProcessors
#r "6.1_BillPay.dll"

type BetterBillProcessor() =
    let calculateTax paymentMethod paymentAmount = 
        match paymentMethod with
        | PaymentType.Chickens -> paymentAmount * 1.17M
        | PaymentType.Mastercard
        | PaymentType.Visa
        | PaymentType.Cash -> paymentAmount * 1.05M

    interface IBillProcessor with
        member this.PayBill(id, bill) =
            let taxedAmount = calculateTax bill.TypeOfPayment bill.Amount
        
            printfn 
                "Paying bill in %d in F#, paid with %A, in the amount of $%.2f on %A." 
                id bill.TypeOfPayment taxedAmount bill.DatePaid
</code></pre>
                </section>
            </section>

            <section>
                <h2>Thank you.</h2>
            </section>


        </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
        // Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});
    </script>

</body>

</html>